CS 144
Lab 3
Gil Shotan

My implementation of lab3 makes use of the layering principle for robustness, reuse of code, and ease of implementation. When I wish to send a packet, I first construct the contents of the ICMP message. I then pass the pointer to the 'wrap_ip' function which wraps the message insider an ip packet, and once the routing logic has been performed, this ip packet gets passed in to to 'wrap_frame', which
wraps it inside an ethernet frame and sends it on its way. Similarly, when I received a packet, my functionality branches according
to the type of packet being recieved. First I determine if its an arp packet or an ip packet, and call 'handle_arp_packet' and 'handloe_ip_packet' respectively. When I handle an IP packet, I branch according to the receiver IP address, calling 'process_ip_packet' if it is addressed to me, and 'route_ip_packet' if not. 'route_ip_packet' contains the main routing logic in my implementation. It receives an IP packet and decides how to forward it along. it is responsible for looking up the entry in the routing table, looking up the next hop in the cache entry, and sending it if everything is in order. It also issues new arp requests when necessary.

The vast majority of my code resides in 'sr_router.c', with a few, more straightforward helper functions located in 'sr_router_utils.c', which I delegated to a seperate file to improve the readibility of 'sr_router.c'. Other than that there are some small modifications
of the 'sr_arpcache' module and 'sr_protocol.h' file. In the 'sr_arpcahce' module, I changed the 'sr_arpreq' struct to explicitly contain the interface through which the arp request has been sent. This is to make retransmission of the request easier (as opposed to having to look through one of the pending packets for this request in order to find this value). 'sr_arpcahce.c' also contains my implementation of 'sr_arpcache_sweepreqs'. In 'sr_protocol.h' I added some more enumerated types to reflect the types and codes of ICMP messages.

As part of my new title of 'Maser' I continued writing unit test for my code. test.c includes 1500 lines of test code which verifies the functionality of my program. The strategy I employed to test my code was to 'hijack' the 'sr_sendpacket' function by declaring an
identical one in my test module 'test.c'. This enabled me to send a packet directly by calling 'sr_handlepacket', and inspect the
packet being sent by the router (if any), and then send another packet in response to that, and in such a manner simulate an exchange
with the router. I also verified the functionality of my code by comparing the tcp dumps generated by my code with the tcp dumps generated by the reference soluion under various testing conditions.

I also included a jpg image, 'funcgraph.jpg' which illustrates the relationship between the functions in my implementation, to help you understand the structure of my code.